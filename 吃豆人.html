<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>经典吃豆人 (Classic Pac-Man)</title>
    <style>
        body {
            margin: 0;
            background-color: #111;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: 'Courier New', Courier, monospace; /* 复古字体 */
            color: white;
            overflow: hidden;
        }

        #game-container {
            position: relative;
            box-shadow: 0 0 20px rgba(0, 0, 255, 0.5);
            border: 4px solid #222;
            border-radius: 4px;
        }

        canvas {
            display: block;
            background-color: #000;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* 让点击穿透到Canvas */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 10px;
            box-sizing: border-box;
        }

        .score-board {
            font-size: 20px;
            font-weight: bold;
            text-shadow: 2px 2px 0 #000;
        }

        .lives {
            text-align: right;
        }

        #overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(0, 0, 0, 0.85);
            padding: 20px 40px;
            border: 2px solid #fff;
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        h1 { margin: 0 0 10px 0; color: #ffeb3b; text-transform: uppercase; letter-spacing: 3px;}
        p { margin: 5px 0; font-size: 14px; color: #ddd; }
        
        button {
            background: #ff0000;
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            font-family: inherit;
            text-transform: uppercase;
            margin-top: 10px;
            border: 2px solid white;
        }

        button:hover {
            background: #cc0000;
        }

        .hidden { display: none !important; }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    
    <!-- UI 层 -->
    <div id="ui-layer">
        <div class="score-board">SCORE: <span id="scoreEl">0</span></div>
        <div class="lives" id="livesEl">LIVES: 3</div>
    </div>

    <!-- 游戏状态遮罩层 -->
    <div id="overlay">
        <h1 id="overlay-title">PAC-MAN</h1>
        <p id="overlay-msg">Use Arrow Keys to Move</p>
        <button id="start-btn">START GAME</button>
    </div>
</div>

<script>
/**
 * 游戏配置与常量
 */
const TILE_SIZE = 24; 
const ENTITY_SPEED = 1.5; 

const WALL_COLOR = '#1919A6'; // 经典街机蓝
const DOT_COLOR = '#FFB8AE';
const POWER_DOT_COLOR = '#FFB8AE'; 

// 固定复活时间 (帧数), 60帧约为1秒。这里设为 300 帧 = 5秒
const FIXED_RESPAWN_TIME = 300; 

// 地图定义
// 1: 墙, 0: 豆子, 2: 能量豆, 3: 空地(无豆), 4: 鬼魂屋门
const mapLayout = [
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,2,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,2,1],
    [1,0,1,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,1,0,1],
    [1,0,1,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,1,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,0,1],
    [1,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,1],
    [1,1,1,1,1,0,1,1,1,3,1,3,1,1,1,0,1,1,1,1,1],
    [3,3,3,3,1,0,1,3,3,3,3,3,3,3,1,0,1,3,3,3,3],
    [1,1,1,1,1,0,1,3,1,1,4,1,1,3,1,0,1,1,1,1,1],
    [3,3,3,3,3,0,3,3,1,3,3,3,1,3,3,0,3,3,3,3,3], // 隧道行
    [1,1,1,1,1,0,1,3,1,1,1,1,1,3,1,0,1,1,1,1,1],
    [3,3,3,3,1,0,1,3,3,3,3,3,3,3,1,0,1,3,3,3,3],
    [1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1],
    [1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1],
    [1,0,1,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,1,0,1],
    [1,2,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,2,1],
    [1,1,1,0,1,0,1,0,1,1,1,1,1,0,1,0,1,0,1,1,1],
    [1,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
];

const ROWS = mapLayout.length;
const COLS = mapLayout[0].length;

// 方向枚举
const DIRECTION = {
    UP: { x: 0, y: -1, angle: 1.5 * Math.PI },
    DOWN: { x: 0, y: 1, angle: 0.5 * Math.PI },
    LEFT: { x: -1, y: 0, angle: Math.PI },
    RIGHT: { x: 1, y: 0, angle: 0 },
    STOP: { x: 0, y: 0, angle: 0 }
};

// 游戏变量
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('scoreEl');
const livesEl = document.getElementById('livesEl');
const overlay = document.getElementById('overlay');
const overlayTitle = document.getElementById('overlay-title');
const overlayMsg = document.getElementById('overlay-msg');
const startBtn = document.getElementById('start-btn');

// 画布设置
canvas.width = COLS * TILE_SIZE;
canvas.height = ROWS * TILE_SIZE;

let gameInterval;
let score = 0;
let lives = 3;
let totalDots = 0;
let isPaused = true;
let powerModeTime = 0; 
let blinkTimer = 0; 

let pacman;
let ghosts = [];
let map = mapLayout.map(row => [...row]);

// 辅助函数：检查坐标是否是墙壁
function isWall(r, c) {
    if (r < 0 || r >= ROWS || c < 0 || c >= COLS) return false; // 越界（隧道）不算墙
    return map[r][c] === 1;
}

class Entity {
    constructor(x, y, color, speed) {
        this.x = x;
        this.y = y;
        this.color = color;
        this.speed = speed;
        this.dir = DIRECTION.STOP;
        this.nextDir = DIRECTION.STOP;
        this.radius = TILE_SIZE * 0.4;
    }

    getGridPos() {
        return {
            col: Math.floor((this.x + TILE_SIZE / 2) / TILE_SIZE),
            row: Math.floor((this.y + TILE_SIZE / 2) / TILE_SIZE)
        };
    }
}

class Pacman extends Entity {
    constructor(x, y) {
        super(x, y, '#FFEB3B', ENTITY_SPEED);
        this.mouthOpen = 0;
        this.mouthSpeed = 0.15; 
    }

    move() {
        // 1. 处理隧道
        if (this.x < -TILE_SIZE/2) this.x = canvas.width + TILE_SIZE/2;
        if (this.x > canvas.width + TILE_SIZE/2) this.x = -TILE_SIZE/2;

        // 2. 获取当前网格中心
        const pos = this.getGridPos();
        const centerX = pos.col * TILE_SIZE;
        const centerY = pos.row * TILE_SIZE;

        // 计算与中心的距离
        const distToCenter = Math.abs(this.x - centerX) + Math.abs(this.y - centerY);

        if (distToCenter < this.speed) {
            // 吸附
            this.x = centerX;
            this.y = centerY;

            // 尝试改变方向
            if (this.nextDir !== DIRECTION.STOP) {
                const nextR = pos.row + this.nextDir.y;
                const nextC = pos.col + this.nextDir.x;
                if (!isWall(nextR, nextC)) {
                    this.dir = this.nextDir;
                    this.nextDir = DIRECTION.STOP;
                }
            }

            // 检查前方是否撞墙
            const forwardR = pos.row + this.dir.y;
            const forwardC = pos.col + this.dir.x;
            if (isWall(forwardR, forwardC)) {
                this.dir = DIRECTION.STOP;
            }
        }

        if (this.dir !== DIRECTION.STOP) {
            this.x += this.dir.x * this.speed;
            this.y += this.dir.y * this.speed;
        }
    }

    update() {
        this.move();
        
        // 嘴巴动画
        this.mouthOpen += this.mouthSpeed;
        if (this.mouthOpen > 0.25 * Math.PI || this.mouthOpen < 0) {
            this.mouthSpeed = -this.mouthSpeed;
        }

        // 吃豆子
        const cx = this.x + TILE_SIZE/2;
        const cy = this.y + TILE_SIZE/2;
        const col = Math.floor(cx / TILE_SIZE);
        const row = Math.floor(cy / TILE_SIZE);

        if (row >= 0 && row < ROWS && col >= 0 && col < COLS) {
            const tile = map[row][col];
            if (tile === 0 || tile === 2) {
                const dist = Math.sqrt((cx - (col*TILE_SIZE+TILE_SIZE/2))**2 + (cy - (row*TILE_SIZE+TILE_SIZE/2))**2);
                if (dist < 5) { 
                    if (tile === 0) {
                        map[row][col] = 3;
                        score += 10;
                        totalDots--;
                        checkWin();
                    } else if (tile === 2) {
                        map[row][col] = 3;
                        score += 50;
                        totalDots--;
                        activatePowerMode();
                        checkWin();
                    }
                }
            }
        }
    }

    draw() {
        ctx.fillStyle = this.color;
        ctx.beginPath();
        let rotation = this.dir.angle || 0;
        if (this.dir === DIRECTION.LEFT) rotation = Math.PI;
        
        ctx.translate(this.x + TILE_SIZE/2, this.y + TILE_SIZE/2);
        ctx.rotate(rotation);
        const actualMouth = (this.dir === DIRECTION.STOP) ? 0.1 : (this.mouthOpen > 0 ? this.mouthOpen : 0);
        
        ctx.arc(0, 0, this.radius, actualMouth, 2 * Math.PI - actualMouth);
        ctx.lineTo(0, 0);
        ctx.fill();
        ctx.rotate(-rotation);
        ctx.translate(-(this.x + TILE_SIZE/2), -(this.y + TILE_SIZE/2));
    }
}

class Ghost extends Entity {
    constructor(x, y, color) {
        super(x, y, color, ENTITY_SPEED);
        this.scared = false;
        this.isEaten = false;
        this.dir = DIRECTION.LEFT; 
        this.respawnTimer = 0; // 复活倒计时
    }

    update() {
        // --- 处理死亡逻辑 ---
        if (this.isEaten) {
            // 倒计时减少
            if (this.respawnTimer > 0) {
                this.respawnTimer--;
            }

            // 复活判断：哪一个时间长取哪一个
            // 只有当 (固定CD结束) 且 (无敌时间结束) 时，才复活
            if (this.respawnTimer <= 0 && powerModeTime <= 0) {
                this.isEaten = false;
                this.scared = false;
                // 复活后让它往上走出门
                this.dir = DIRECTION.UP; 
            } else {
                // 如果还没到时间，保持在鬼屋位置不动 (或者可以做一个简单的上下浮动动画，这里保持静止)
                this.x = 10 * TILE_SIZE;
                this.y = 8 * TILE_SIZE;
                return; // 死亡状态下不执行后续移动逻辑
            }
        }

        // --- 正常移动逻辑 ---
        
        // 速度计算
        let currentSpeed = this.speed;
        if (this.scared) currentSpeed /= 2; // 恐惧时减速

        // 移动
        this.x += this.dir.x * currentSpeed;
        this.y += this.dir.y * currentSpeed;

        // 隧道
        if (this.x <= -TILE_SIZE) {
            this.x = canvas.width + TILE_SIZE;
        } else if (this.x >= canvas.width + TILE_SIZE) {
            this.x = -TILE_SIZE;
        }

        // 决策逻辑
        const pos = this.getGridPos();
        const centerX = pos.col * TILE_SIZE;
        const centerY = pos.row * TILE_SIZE;
        const distToCenter = Math.abs(this.x - centerX) + Math.abs(this.y - centerY);

        if (distToCenter < currentSpeed) {
            this.x = centerX;
            this.y = centerY;
            
            if (pos.row >= 0 && pos.row < ROWS && pos.col >= 0 && pos.col < COLS) {
                this.decideDirection(pos.row, pos.col);
            }
        }
    }

    decideDirection(row, col) {
        const options = [];
        const dirs = [DIRECTION.UP, DIRECTION.DOWN, DIRECTION.LEFT, DIRECTION.RIGHT];

        for (let d of dirs) {
            const nextR = row + d.y;
            const nextC = col + d.x;
            
            if (nextR >= 0 && nextR < ROWS && nextC >= 0 && nextC < COLS) {
                if (map[nextR][nextC] !== 1) options.push(d);
            } else if (nextC < 0 || nextC >= COLS) {
                options.push(d);
            }
        }

        if (options.length === 0) return; 

        if (options.length > 1) {
            const oppositeDirX = -this.dir.x;
            const oppositeDirY = -this.dir.y;
            const noUturnOptions = options.filter(d => !(d.x === oppositeDirX && d.y === oppositeDirY));
            
            if (noUturnOptions.length > 0) {
                this.dir = noUturnOptions[Math.floor(Math.random() * noUturnOptions.length)];
            } else {
                this.dir = options[0];
            }
        } else {
            this.dir = options[0];
        }
    }

    draw() {
        const cx = this.x + TILE_SIZE/2;
        const cy = this.y + TILE_SIZE/2;

        // 如果死亡，只画眼睛（且颜色灰暗），位置固定在家里
        if (this.isEaten) {
            ctx.fillStyle = '#555'; // 灰色眼白
            ctx.beginPath();
            ctx.arc(cx - 4, cy - 4, 3, 0, Math.PI * 2);
            ctx.arc(cx + 4, cy - 4, 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#ccc'; // 浅灰眼珠
            ctx.beginPath();
            ctx.arc(cx - 4, cy - 4, 1.5, 0, Math.PI * 2);
            ctx.arc(cx + 4, cy - 4, 1.5, 0, Math.PI * 2);
            ctx.fill();
            return;
        }

        // 正常绘制
        let drawColor = this.color;
        if (this.scared) {
            if (powerModeTime < 120 && Math.floor(Date.now() / 200) % 2 === 0) {
                drawColor = '#FFFFFF';
            } else {
                drawColor = '#0000FF'; 
            }
        }

        ctx.fillStyle = drawColor;
        ctx.beginPath();
        ctx.arc(cx, cy - 2, this.radius, Math.PI, 0);
        ctx.lineTo(cx + this.radius, cy + this.radius);
        for(let i=1; i<=3; i++) {
            ctx.lineTo(cx + this.radius - (2 * this.radius / 3) * i, cy + this.radius - (i%2==0?0:3));
        }
        ctx.lineTo(cx - this.radius, cy + this.radius);
        ctx.fill();

        if (!this.scared) {
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(cx - 4, cy - 4, 3, 0, Math.PI * 2);
            ctx.arc(cx + 4, cy - 4, 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = 'blue';
            ctx.beginPath();
            const eyeOffX = this.dir.x * 2;
            const eyeOffY = this.dir.y * 2;
            ctx.arc(cx - 4 + eyeOffX, cy - 4 + eyeOffY, 1.5, 0, Math.PI * 2);
            ctx.arc(cx + 4 + eyeOffX, cy - 4 + eyeOffY, 1.5, 0, Math.PI * 2);
            ctx.fill();
        } else {
            ctx.fillStyle = '#ffcccc';
            ctx.fillRect(cx - 6, cy - 2, 4, 2);
            ctx.fillRect(cx + 2, cy - 2, 4, 2);
            ctx.fillRect(cx - 6, cy + 3, 12, 2); 
        }
    }
}

/**
 * 游戏流程控制
 */

function initGame() {
    score = 0;
    lives = 3;
    updateUI();
    resetLevel(true);
}

function resetLevel(fullReset = false) {
    if (fullReset) {
        map = mapLayout.map(row => [...row]);
        totalDots = 0;
        for(let r=0; r<ROWS; r++) {
            for(let c=0; c<COLS; c++) {
                if(map[r][c] === 0 || map[r][c] === 2) totalDots++;
            }
        }
    }

    pacman = new Pacman(10 * TILE_SIZE, 15 * TILE_SIZE);
    pacman.dir = DIRECTION.STOP; 
    pacman.nextDir = DIRECTION.LEFT; 

    ghosts = [
        new Ghost(9 * TILE_SIZE, 8 * TILE_SIZE, '#FF0000'),
        new Ghost(10 * TILE_SIZE, 8 * TILE_SIZE, '#FFB8FF'),
        new Ghost(11 * TILE_SIZE, 8 * TILE_SIZE, '#00FFFF'),
        new Ghost(10 * TILE_SIZE, 7 * TILE_SIZE, '#FFB852') 
    ];
    ghosts[0].dir = DIRECTION.LEFT;
    ghosts[1].dir = DIRECTION.UP;
    ghosts[2].dir = DIRECTION.RIGHT;
    ghosts[3].dir = DIRECTION.UP;
    
    isPaused = false;
}

function activatePowerMode() {
    powerModeTime = 600; 
    ghosts.forEach(g => {
        // 如果鬼魂没死，就变身；如果死了，保持死的状态（等待复活）
        if (!g.isEaten) g.scared = true;
    });
}

function checkCollisions() {
    ghosts.forEach(ghost => {
        if (ghost.isEaten) return; // 死了就不检测碰撞

        const distThreshold = TILE_SIZE * 0.6; 
        const dx = pacman.x - ghost.x;
        const dy = pacman.y - ghost.y;
        const distance = Math.sqrt(dx * dx + dy * dy);

        if (distance < distThreshold) {
            if (ghost.scared) {
                // 吃掉鬼魂
                ghost.isEaten = true;
                ghost.scared = false;
                // 回到家
                ghost.x = 10 * TILE_SIZE;
                ghost.y = 8 * TILE_SIZE;
                
                // 设置复活倒计时
                ghost.respawnTimer = FIXED_RESPAWN_TIME;

                score += 200;
                updateUI();
            } else {
                handleDeath();
            }
        }
    });
}

function handleDeath() {
    lives--;
    updateUI();
    isPaused = true;
    
    if (lives <= 0) {
        showOverlay("GAME OVER", "Final Score: " + score, "TRY AGAIN");
    } else {
        setTimeout(() => {
            resetLevel(false);
            isPaused = false;
        }, 1500);
    }
}

function checkWin() {
    updateUI();
    if (totalDots <= 0) {
        isPaused = true;
        showOverlay("YOU WIN!", "Score: " + score, "PLAY AGAIN");
    }
}

function updateUI() {
    scoreEl.innerText = score;
    livesEl.innerHTML = 'LIVES: ' + '● '.repeat(lives); 
}

function drawMap() {
    ctx.lineWidth = 2;
    for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
            const tile = map[r][c];
            const x = c * TILE_SIZE;
            const y = r * TILE_SIZE;

            if (tile === 1) {
                ctx.strokeStyle = WALL_COLOR;
                ctx.strokeRect(x + 4, y + 4, TILE_SIZE - 8, TILE_SIZE - 8);
            } else if (tile === 0) {
                ctx.fillStyle = DOT_COLOR;
                ctx.beginPath();
                ctx.arc(x + TILE_SIZE/2, y + TILE_SIZE/2, 2, 0, Math.PI * 2);
                ctx.fill();
            } else if (tile === 2) {
                blinkTimer++;
                if (Math.floor(blinkTimer / 20) % 2 === 0) {
                    ctx.fillStyle = POWER_DOT_COLOR;
                    ctx.beginPath();
                    ctx.arc(x + TILE_SIZE/2, y + TILE_SIZE/2, 7, 0, Math.PI * 2);
                    ctx.fill();
                }
            } else if (tile === 4) {
                 ctx.strokeStyle = 'pink';
                 ctx.beginPath();
                 ctx.moveTo(x, y + TILE_SIZE/2);
                 ctx.lineTo(x + TILE_SIZE, y + TILE_SIZE/2);
                 ctx.stroke();
            }
        }
    }
}

function gameLoop() {
    if (!isPaused) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawMap();
        pacman.update();
        pacman.draw();
        ghosts.forEach(ghost => {
            ghost.update();
            ghost.draw();
        });
        checkCollisions();

        if (powerModeTime > 0) {
            powerModeTime--;
            // 当无敌时间结束，如果鬼魂还没死，就恢复正常
            if (powerModeTime === 0) {
                ghosts.forEach(g => {
                    if(!g.isEaten) g.scared = false;
                });
            }
        }
    }
    gameInterval = requestAnimationFrame(gameLoop);
}

function showOverlay(title, msg, btnText) {
    overlayTitle.innerText = title;
    overlayMsg.innerText = msg;
    startBtn.innerText = btnText;
    overlay.classList.remove('hidden');
}

function hideOverlay() {
    overlay.classList.add('hidden');
}

window.addEventListener('keydown', (e) => {
    if (isPaused && lives > 0 && totalDots > 0) return;
    if(["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"].indexOf(e.code) > -1) {
        e.preventDefault();
    }
    switch(e.key) {
        case 'ArrowUp': pacman.nextDir = DIRECTION.UP; break;
        case 'ArrowDown': pacman.nextDir = DIRECTION.DOWN; break;
        case 'ArrowLeft': pacman.nextDir = DIRECTION.LEFT; break;
        case 'ArrowRight': pacman.nextDir = DIRECTION.RIGHT; break;
    }
});

startBtn.addEventListener('click', () => {
    hideOverlay();
    if (lives <= 0 || totalDots <= 0 || score === 0) {
        initGame(); 
    } else {
        isPaused = false;
    }
    if (!gameInterval) gameLoop();
});

// 初始绘制
drawMap();

</script>
</body>
</html>