<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D 交互式太阳系 - Three.js</title>
    <style>
        body {
            margin: 0;
            overflow: hidden; /* 防止滚动条 */
            background-color: #000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        /* 加载提示 */
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            pointer-events: none;
            transition: opacity 0.5s;
        }

        /* 行星名称标签样式 */
        #planet-label {
            position: absolute;
            color: #fff;
            background: rgba(0, 0, 0, 0.7);
            padding: 5px 10px;
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            pointer-events: none; /* 让鼠标事件穿透标签 */
            display: none; /* 默认隐藏 */
            font-size: 14px;
            text-shadow: 0 0 5px #000;
            z-index: 10;
            white-space: nowrap;
        }

        /* 左上角控制说明 */
        #controls-info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: rgba(255, 255, 255, 0.6);
            font-size: 12px;
            pointer-events: none;
        }
    </style>
</head>
<body>

    <!-- 标签容器 -->
    <div id="planet-label">Planet Name</div>
    <div id="controls-info">
        左键拖动：旋转视角 | 滚轮：缩放 | 右键拖动：平移<br>
        悬停行星查看名称
    </div>

    <!-- 引入 Three.js 和 OrbitControls -->
    <!-- 使用 CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        /**
         * 配置参数
         * 注意：为了在屏幕上可视化，这里的比例并非真实天文比例，而是经过了艺术化缩放。
         */
        const CONFIG = {
            sunSize: 15,
            orbitScale: 10, // 轨道距离乘数
            speedFactor: 0.2, // 全局公转速度系数
            planetScale: 1.5  // 行星大小系数
        };

        // 行星数据：名称、颜色(十六进制)、大小(相对半径)、距离(距太阳)、公转速度、自转速度
        const planetsData = [
            { name: "水星 (Mercury)", color: 0xA5A5A5, size: 0.8, distance: 25, speed: 0.04, rotateSpeed: 0.004 },
            { name: "金星 (Venus)", color: 0xE3BB76, size: 1.5, distance: 35, speed: 0.015, rotateSpeed: -0.002 }, // 金星逆向自转
            { name: "地球 (Earth)", color: 0x2233FF, size: 1.6, distance: 48, speed: 0.01, rotateSpeed: 0.02 },
            { name: "火星 (Mars)", color: 0xDD4422, size: 1.2, distance: 62, speed: 0.008, rotateSpeed: 0.018 },
            { name: "木星 (Jupiter)", color: 0xD9A066, size: 5.0, distance: 90, speed: 0.004, rotateSpeed: 0.04 },
            { name: "土星 (Saturn)", color: 0xE6DBA0, size: 4.2, distance: 120, speed: 0.003, rotateSpeed: 0.038, hasRing: true },
            { name: "天王星 (Uranus)", color: 0x88FFFF, size: 3.0, distance: 150, speed: 0.002, rotateSpeed: 0.03 },
            { name: "海王星 (Neptune)", color: 0x3366FF, size: 2.9, distance: 175, speed: 0.001, rotateSpeed: 0.032 },
            { name: "冥王星 (Pluto)", color: 0x998877, size: 0.6, distance: 200, speed: 0.0007, rotateSpeed: 0.005 }
        ];

        // 全局变量
        let scene, camera, renderer, controls;
        let sun;
        let planetMeshes = []; // 存储行星Mesh对象以便更新动画
        let raycaster, mouse;
        let labelDiv;

        function init() {
            // 1. 场景搭建
            scene = new THREE.Scene();
            // 雾化效果，增加深邃感
            scene.fog = new THREE.FogExp2(0x000000, 0.0015);

            // 2. 相机设置
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.set(0, 120, 200); // 初始视角位置
            camera.lookAt(0, 0, 0);

            // 3. 渲染器设置
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            // 4. 交互控制器 (OrbitControls)
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; // 开启阻尼，使旋转更丝滑
            controls.dampingFactor = 0.05;
            controls.minDistance = 30; // 最小缩放距离
            controls.maxDistance = 800; // 最大缩放距离

            // 5. 灯光系统
            // 环境光：给整个场景一个微弱的基础亮度
            const ambientLight = new THREE.AmbientLight(0x333333);
            scene.add(ambientLight);

            // 点光源：位于太阳中心，照亮行星
            const sunLight = new THREE.PointLight(0xFFFFFF, 2, 400); // 颜色，强度，照射距离
            scene.add(sunLight);

            // 6. 创建天体
            createStarField(); // 背景星空
            createSun();       // 太阳
            createPlanets();   // 九大行星

            // 7. 交互射线检测 (Raycaster)
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            labelDiv = document.getElementById('planet-label');

            // 事件监听
            window.addEventListener('resize', onWindowResize, false);
            window.addEventListener('mousemove', onMouseMove, false);

            // 开始动画循环
            animate();
        }

        /**
         * 创建程序化生成的星空背景
         */
        function createStarField() {
            const geometry = new THREE.BufferGeometry();
            const count = 3000; // 星星数量
            const positions = new Float32Array(count * 3);
            
            for (let i = 0; i < count * 3; i++) {
                // 在大范围内随机分布
                positions[i] = (Math.random() - 0.5) * 1500;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const material = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 1.5,
                sizeAttenuation: true // 远处的星星变小
            });

            const stars = new THREE.Points(geometry, material);
            scene.add(stars);
        }

        /**
         * 创建太阳
         */
        function createSun() {
            const geometry = new THREE.SphereGeometry(CONFIG.sunSize, 64, 64);
            
            // 太阳材质：使用BasicMaterial因为它自身发光，不需要反射光线
            // 这里我们创建一个简单的动态程序化纹理
            const texture = generateSunTexture();
            
            const material = new THREE.MeshBasicMaterial({ 
                map: texture,
                color: 0xffddaa 
            });
            
            sun = new THREE.Mesh(geometry, material);
            
            // 添加太阳的光晕效果（简单的两层发光网格）
            const glowGeo = new THREE.SphereGeometry(CONFIG.sunSize * 1.2, 32, 32);
            const glowMat = new THREE.MeshBasicMaterial({
                color: 0xffaa00,
                transparent: true,
                opacity: 0.15,
                side: THREE.BackSide
            });
            const glow = new THREE.Mesh(glowGeo, glowMat);
            sun.add(glow);

            scene.add(sun);
        }

        /**
         * 创建所有行星
         */
        function createPlanets() {
            planetsData.forEach(data => {
                // 1. 创建轨道组 (Pivot Point) - 位于太阳中心(0,0,0)
                // 我们将旋转这个组来实现公转
                const orbitGroup = new THREE.Group();
                scene.add(orbitGroup);

                // 2. 绘制轨道线 (视觉辅助)
                const orbitPathGeo = new THREE.RingGeometry(data.distance - 0.2, data.distance + 0.2, 128);
                // 旋转轨道线使其平铺在XZ平面
                orbitPathGeo.rotateX(-Math.PI / 2); 
                const orbitPathMat = new THREE.MeshBasicMaterial({ 
                    color: 0xffffff, 
                    opacity: 0.15, 
                    transparent: true, 
                    side: THREE.DoubleSide 
                });
                const orbitPath = new THREE.Mesh(orbitPathGeo, orbitPathMat);
                scene.add(orbitPath);

                // 3. 创建行星本身
                const geometry = new THREE.SphereGeometry(data.size * CONFIG.planetScale, 32, 32);
                
                // 生成纹理 (如果有真实图片 URL，可以在这里替换)
                // 示例: new THREE.TextureLoader().load('./textures/earth.jpg');
                const texture = generatePlanetTexture(data.color, data.name === '木星 (Jupiter)');
                
                const material = new THREE.MeshStandardMaterial({
                    map: texture,
                    roughness: 0.7, // 粗糙度
                    metalness: 0.1  // 金属度
                });

                const planet = new THREE.Mesh(geometry, material);
                
                // 设置行星初始位置
                planet.position.set(data.distance, 0, 0);
                
                // 自转轴倾斜 (随机一点倾斜增加真实感，地球是23度)
                planet.rotation.z = Math.random() * 0.5; 

                // 存储自定义数据供射线检测和动画使用
                planet.userData = { 
                    name: data.name,
                    rotateSpeed: data.rotateSpeed,
                    distance: data.distance,
                    speed: data.speed,
                    angle: Math.random() * Math.PI * 2 // 初始随机公转角度
                };

                // 4. 特殊处理：土星光环
                if (data.hasRing) {
                    const ringGeo = new THREE.RingGeometry(
                        (data.size * CONFIG.planetScale) * 1.4, 
                        (data.size * CONFIG.planetScale) * 2.4, 
                        64
                    );
                    const ringTex = generateRingTexture();
                    const ringMat = new THREE.MeshBasicMaterial({
                        map: ringTex,
                        color: 0xffffff,
                        side: THREE.DoubleSide,
                        transparent: true,
                        opacity: 0.8
                    });
                    const ring = new THREE.Mesh(ringGeo, ringMat);
                    ring.rotation.x = Math.PI / 2; // 放平
                    ring.rotation.y = -0.2; // 稍微倾斜
                    planet.add(ring);
                }

                // 将行星添加到场景（而不是添加到轨道组，因为我们要手动计算位置以实现更灵活的控制）
                scene.add(planet);
                planetMeshes.push(planet);
            });
        }

        // --- 辅助函数：程序化生成纹理 (避免加载外部图片时的跨域问题) ---

        // 生成类似木星的条纹或普通噪点纹理
        function generatePlanetTexture(baseColorHex, isGasGiant = false) {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            const color = new THREE.Color(baseColorHex);

            // 填充背景
            ctx.fillStyle = `#${color.getHexString()}`;
            ctx.fillRect(0, 0, 512, 512);

            // 添加噪点/细节
            for (let i = 0; i < 100; i++) {
                ctx.globalAlpha = 0.1;
                ctx.fillStyle = isGasGiant ? 
                    (Math.random() > 0.5 ? '#ffffff' : '#552200') : // 条纹色
                    '#ffffff'; // 陨石坑色
                
                if (isGasGiant) {
                    // 绘制横向条纹
                    const y = Math.random() * 512;
                    const h = Math.random() * 50;
                    ctx.fillRect(0, y, 512, h);
                } else {
                    // 绘制随机斑点
                    const x = Math.random() * 512;
                    const y = Math.random() * 512;
                    const r = Math.random() * 20;
                    ctx.beginPath();
                    ctx.arc(x, y, r, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            // 如果是地球，画点蓝色的“海”
            if (baseColorHex === 0x2233FF) {
                ctx.globalAlpha = 0.3;
                ctx.fillStyle = '#00ff00'; // 简单的陆地色块
                for(let k=0; k<10; k++) {
                   ctx.beginPath();
                   ctx.arc(Math.random()*512, Math.random()*512, Math.random()*80, 0, Math.PI*2);
                   ctx.fill(); 
                }
            }

            const texture = new THREE.CanvasTexture(canvas);
            return texture;
        }

        // 生成太阳纹理
        function generateSunTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            const grd = ctx.createRadialGradient(256, 256, 0, 256, 256, 256);
            grd.addColorStop(0, "#ffffee");
            grd.addColorStop(0.5, "#ffaa00");
            grd.addColorStop(1, "#cc4400");
            
            ctx.fillStyle = grd;
            ctx.fillRect(0, 0, 512, 512);
            
            return new THREE.CanvasTexture(canvas);
        }

        // 生成光环纹理
        function generateRingTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 32;
            const ctx = canvas.getContext('2d');
            
            // 垂直渐变模拟环的疏密
            const gradient = ctx.createLinearGradient(0, 0, 0, 32);
            gradient.addColorStop(0, "rgba(200, 180, 150, 0)");
            gradient.addColorStop(0.2, "rgba(200, 180, 150, 0.8)");
            gradient.addColorStop(0.5, "rgba(200, 180, 150, 0.1)");
            gradient.addColorStop(0.8, "rgba(200, 180, 150, 0.8)");
            gradient.addColorStop(1, "rgba(200, 180, 150, 0)");
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0,0, 256, 32);
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.center.set(0.5, 0.5);
            texture.rotation = Math.PI / 2; // 旋转纹理以适应环几何
            return texture;
        }

        // --- 动画与交互逻辑 ---

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onMouseMove(event) {
            // 计算鼠标在屏幕上的归一化坐标 (-1 到 +1)
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            // 更新标签位置（跟随鼠标但稍微偏移）
            labelDiv.style.left = (event.clientX + 15) + 'px';
            labelDiv.style.top = (event.clientY + 15) + 'px';
        }

        function animate() {
            requestAnimationFrame(animate);

            const time = Date.now() * 0.0005; // 全局时间系数

            // 1. 太阳自转
            sun.rotation.y += 0.002;

            // 2. 行星运动
            planetMeshes.forEach(mesh => {
                const data = mesh.userData;

                // 自转
                mesh.rotation.y += data.rotateSpeed;

                // 公转计算 (x = cos, z = sin)
                // 更新当前角度
                data.angle += data.speed * CONFIG.speedFactor;
                
                mesh.position.x = Math.cos(data.angle) * data.distance;
                mesh.position.z = Math.sin(data.angle) * data.distance;
            });

            // 3. 射线检测 (Hover 效果)
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(planetMeshes);

            if (intersects.length > 0) {
                // 鼠标悬停在某行星上
                const target = intersects[0].object;
                
                // 高亮处理 (稍微放大一点或改变颜色，这里用简单的放大)
                document.body.style.cursor = 'pointer';
                labelDiv.innerText = target.userData.name;
                labelDiv.style.display = 'block';
            } else {
                document.body.style.cursor = 'default';
                labelDiv.style.display = 'none';
            }

            controls.update();
            renderer.render(scene, camera);
        }

        // 启动
        init();

    </script>
</body>
</html>